{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>O objetivo deste projeto \u00e9 estudar diferentes algoritmos para obter uma solu\u00e7\u00e3o de alto desempenho.</p>"},{"location":"#alto-desempenho","title":"Alto desempenho","text":"<p>Uma solu\u00e7\u00e3o de alto desempeho depende de tr\u00eas fatores:  </p> <ol> <li>algoritmos eficientes  </li> <li>implementa\u00e7\u00f5es eficientes  </li> <li>paralelismo  </li> </ol>"},{"location":"#problemas","title":"Problemas","text":"<p>Em problemas muito grandes ou complexos, muitas vezes n\u00e3o \u00e9 poss\u00edvel obter uma solu\u00e7\u00e3o decisiva \u00f3tima globalmente, sendo necess\u00e1rio utilizar heur\u00edsticas para encontrar uma solu\u00e7\u00e3o \u00f3tima ou sub-\u00f3tima. O que \u00e9 considerado uma solu\u00e7\u00e3o boa varia de acordo com o problema e o contexto em que ele se encontra, sendo necess\u00e1rio comparar os resultados de diversas heur\u00edsticas.</p>"},{"location":"Problema/","title":"Problema","text":"<p>Para estudar e entender as heuriscas foi criado um problema (Maratona de Filmes) para testar.  </p>"},{"location":"Problema/#maratona-de-filmes","title":"Maratona de Filmes","text":"<p>Retirado do site da materia</p> <p>Voc\u00ea quer passar um final de semana assistindo ao m\u00e1ximo de filmes poss\u00edvel, mas h\u00e1 restri\u00e7\u00f5es quanto aos hor\u00e1rios dispon\u00edveis e ao n\u00famero de t\u00edtulos que podem ser vistos em cada categoria (com\u00e9dia, drama, a\u00e7\u00e3o, etc).  </p> <p>Entrada: Um inteiro N representando o n\u00famero de filmes dispon\u00edveis para assistir e N trios de inteiros (H[i], F[i], C[i]), representando a hora de in\u00edcio, a hora de fim e a categoria do i-\u00e9simo filme. Al\u00e9m disso, um inteiro M representando o n\u00famero de categorias e uma lista de M inteiros representando o n\u00famero m\u00e1ximo de filmes que podem ser assistidos em cada categoria.</p> <p>Sa\u00edda: Um inteiro representando o n\u00famero m\u00e1ximo de filmes que podem ser assistidos de acordo com as restri\u00e7\u00f5es de hor\u00e1rios e n\u00famero m\u00e1ximo por categoria.  </p>"},{"location":"Problema/#exemplo-de-de-input","title":"Exemplo de de input","text":"<p>Como exemplo, considere o seguinte arquivo input.txt gerado:</p> <pre><code>10 4\n1 3 1 2  \n11 13 3  \n14 15 3  \n10 16 2  \n10 14 1  \n11 17 2  \n11 14 3  \n13 15 3  \n14 15 1  \n12 16 4  \n12 13 4  \n</code></pre> <ul> <li>a primeira linha indica a quantidade de filmes (10) e categorias(4);  </li> <li>a segunda linha indica o m\u00e1ximo de filmes que cada categoria pode ter;  </li> <li>da terceira linha em diante, os n filmes, suas respectivas hora de in\u00edcio, hora de t\u00e9rmino e categoria pertencente.  </li> </ul>"},{"location":"metodologia/","title":"Metodologia","text":"<p>Para todas as heur\u00edsticas, foram utilizados os mesmos arquivos de entrada, modelo de sa\u00edda e simplifica\u00e7\u00f5es gerais, embora possam existir simplifica\u00e7\u00f5es ou limita\u00e7\u00f5es espec\u00edficas descritas em sua implementa\u00e7\u00e3o.</p>"},{"location":"metodologia/#inputs","title":"Inputs","text":"<p>Utilizou-se um gerador de entradas que criou diversos arquivos, variando os par\u00e2metros, quantidade de filmes, categorias e limite de filmes por categoria, al\u00e9m de gerar filmes aleat\u00f3rios (com hor\u00e1rio de in\u00edcio, fim e categoria).</p>"},{"location":"metodologia/#especificacoes","title":"Especifica\u00e7\u00f5es:","text":"<ul> <li>Quantidade de filmes: 10 - 100000000</li> <li>Quantidade de categorias: 1 - 9</li> <li>Limite de filme: </li> <li>Dura\u00e7\u00e3o dos filmes: </li> </ul>"},{"location":"metodologia/#ex","title":"Ex:","text":"<pre><code>10 4\n1 3 1 2  \n11 13 3  \n14 15 3  \n10 16 2  \n10 14 1  \n11 17 2  \n11 14 3  \n13 15 3  \n14 15 1  \n12 16 4  \n</code></pre>"},{"location":"metodologia/#simplificacoes-do-problema","title":"Simplifica\u00e7\u00f5es do problema","text":"<p>Para simplificar o problema, n\u00e3o foi imposto um m\u00ednimo de filmes por categoria, e tamb\u00e9m n\u00e3o foram considerados filmes que terminassem no dia seguinte, uma vez que isso aumentaria significativamente a complexidade do desenvolvimento das heur\u00edsticas.</p>"},{"location":"metodologia/#outputs","title":"Outputs","text":"<p>Para cada arquivo de entrada, gerou-se um arquivo de sa\u00edda contendo informa\u00e7\u00f5es sobre o input recebido e m\u00e9tricas de desempenho no modelo: quantidade de filmes, quantidade de categorias, tempo de processamento e tempo de exibi\u00e7\u00e3o. O tempo de processamento refere-se ao tempo em microssegundos que o algoritmo levou para gerar o output, enquanto o tempo de exibi\u00e7\u00e3o \u00e9 a soma da dura\u00e7\u00e3o de todos os filmes assistidos.</p>"},{"location":"metodologia/#ex_1","title":"Ex:","text":"<pre><code>(1000 6 0002 17)\n</code></pre>"},{"location":"heuristicas/Aleatoria/","title":"Aleatoria","text":""},{"location":"heuristicas/Aleatoria/#definicao","title":"Defini\u00e7\u00e3o","text":"<p>Heur\u00edstica aleat\u00f3ria \u00e9 um algoritimo de busca que utiliza elementos aleat\u00f3rios em seu processo de busca por solu\u00e7\u00f5es.</p> <p>O algoritimo utiliza a aleatoriedade para explorar o espa\u00e7o de busca de forma ampla e diversificada, em vez de se concentrar em um caminho espec\u00edfico. Isso permite que a heur\u00edstica encontre solu\u00e7\u00f5es que podem ser menos \u00f3bvias que seriam ignoradas por outras mais determin\u00edsticas.</p>"},{"location":"heuristicas/Aleatoria/#vantagens","title":"Vantagens","text":"<ul> <li>Explora\u00e7\u00e3o ampla: explora o espa\u00e7o de busca de forma ampla, maior as chances de encontrar solu\u00e7\u00f5es menos \u00f3bvias.</li> <li>Flexibilidade: n\u00e3o segue uma estrat\u00e9gia determin\u00edstica, \u00e9 mais flex\u00edvel em termos de adapta\u00e7\u00e3o podendo ser aplicada em uma ampla variedade de contextos.</li> </ul>"},{"location":"heuristicas/Aleatoria/#desvantagens","title":"Desvantagens","text":"<ul> <li>Solu\u00e7\u00f5es sub-\u00f3timas: A escolha aleat\u00f3ria de op\u00e7\u00f5es pode levar a solu\u00e7\u00f5es sub-\u00f3timas.</li> <li>Lentid\u00e3o: Pode precisar avaliar um grande n\u00famero de solu\u00e7\u00f5es antes de encontrar uma solu\u00e7\u00e3o aceit\u00e1vel.</li> </ul>"},{"location":"heuristicas/Aleatoria/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<pre><code>#include&lt;iostream&gt;\n#include&lt;iomanip&gt;\n#include&lt;vector&gt;\n#include&lt;fstream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\n#include&lt;chrono&gt;\n#include &lt;random&gt;\n#include&lt;boost/random.hpp&gt;\nusing namespace std;\nstruct filme{\nint inicio;\nint fim;\nint categoria;\nint duracao;\nint id;\n};\nbool ord_duracao(filme a, filme b);\nbool ord_inicio(filme a, filme b);\nvoid output(vector&lt;filme&gt; assistir);\nint main(int argc, char *argv[]){\nifstream inFile;\nstring fileName = argv[1]; int n;\nint nCat;\nint cat;\nvector&lt;int&gt; categorias;\nvector&lt;bool&gt; agenda;\nvector&lt;filme&gt; filmes;\nvector&lt;filme&gt; assistir;\nvector&lt;filme&gt; melhor;\nvector&lt;filme&gt; tmp;\nassistir.reserve(24);\ndefault_random_engine generator (10);\nuniform_real_distribution&lt;double&gt; distribution(0.0, 1.0);\ninFile.open(\"inputs/\" + fileName + \".txt\");\nif (!inFile) {\ncout &lt;&lt; \"Unable to open file\";\nexit(1); // terminate with error\n}\ninFile &gt;&gt; n;\ninFile &gt;&gt; nCat;\nfor (int i = 0; i &lt; nCat; i++){\ninFile &gt;&gt; cat;\ncategorias.push_back(cat);\n}\nfor (int i = 0; i &lt; 24; i++){\nagenda.push_back(true);\n}\nfor(int i = 0; i &lt; n; i++){\nfilme k;\nint inicio, fim, categoria;\ninFile &gt;&gt; inicio;\ninFile &gt;&gt; fim;\ninFile &gt;&gt; categoria;\nif(fim &gt; inicio){\nk.fim = fim;\nk.inicio = inicio;\nk.duracao = k.fim - k.inicio;\nk.categoria = categoria;\nk.id = i + 3;\nfilmes.push_back(k);\n}        }\nbool disponivel = true;\nint maratona = 0;\nsize_t maxFilmes = 0;\nsort(filmes.begin(), filmes.end(), ord_duracao);\nchrono::steady_clock::time_point start = chrono::steady_clock::now();\nsort(filmes.begin(), filmes.end(), ord_inicio);\ntmp = filmes;\nfor (int t = 0; t &lt; 10; t++){    filmes = tmp;\nassistir.clear();\nfor (size_t i = 0; i &lt; filmes.size(); i++){\ndisponivel = all_of(agenda.begin() + filmes[i].inicio, agenda.begin() + filmes[i].fim, [](bool b){ return b == true; });\nif (categorias[filmes[i].categoria - 1] &lt;= 0){\ndisponivel = false;\n}\nif (disponivel){\nint categoria_index = filmes[i].categoria - 1;\nfor (int k = filmes[i].inicio; k &lt; filmes[i].fim; k++){\nagenda[k] = false;\n}\nassistir.push_back(filmes[i]);\nmaratona += filmes[i].duracao;\ncategorias[categoria_index] -= 1; }  disponivel = true; if(distribution(generator) &lt; 0.25){\nuniform_int_distribution&lt;int&gt; distribution(i, filmes.size()-1);\nint p = distribution(generator);\ndisponivel = all_of(agenda.begin() + filmes[p].inicio, agenda.begin() + filmes[p].fim, [](bool b){ return b == true; });\nif (categorias[filmes[p].categoria - 1] &lt;= 0){\ndisponivel = false;\n}\nif (disponivel){\nint categoria_index = filmes[p].categoria - 1;\nfor (int k = filmes[p].inicio; k &lt; filmes[p].fim; k++){\nagenda[k] = false;\n}\nassistir.push_back(filmes[p]);\nmaratona += filmes[p].duracao;\ncategorias[categoria_index] -= 1; }  filmes.erase(filmes.begin() + p);\ndisponivel = true; }\n}\nif(maxFilmes &lt; assistir.size()){\nmaxFilmes = assistir.size();\nmelhor = assistir;\n}\nfor (int i = 0; i &lt; 24; i++){\nagenda[i] = true;\n}\n}\nchrono::steady_clock::time_point end = chrono::steady_clock::now();\ncout &lt;&lt; n &lt;&lt; ' ' &lt;&lt; nCat &lt;&lt; ' ' &lt;&lt; chrono::duration_cast&lt;chrono::microseconds&gt;(end-start).count() &lt;&lt; ' ' &lt;&lt; melhor.size() &lt;&lt; endl;\nif(argc &gt; 2 &amp;&amp; strcmp(argv[2], \"-output\") == 0){ cout &lt;&lt; \"Quantidade de filmes:\" &lt;&lt; melhor.size() &lt;&lt; endl;\n//cout &lt;&lt; \"Tempo para assistir:\" &lt;&lt; maratona &lt;&lt; endl;\nsort(melhor.begin(), melhor.end(), ord_inicio);\noutput(melhor);\n}\nofstream outFile;\noutFile.open(\"outputs/aleatorio/out_\" + to_string(n) + \"_\" + to_string(nCat) + \".txt\");\nif (!outFile) {\ncout &lt;&lt; \"Unable to open file\";\nexit(1); // terminate with error\n}\noutFile &lt;&lt;  n &lt;&lt; ' ' &lt;&lt; nCat &lt;&lt; ' ' &lt;&lt; chrono::duration_cast&lt;chrono::microseconds&gt;(end-start).count() &lt;&lt; ' ' &lt;&lt; assistir.size() &lt;&lt; endl;\nreturn 0;\n}\nbool ord_duracao(filme a, filme b){\nreturn a.duracao &lt; b.duracao;\n}\nbool ord_inicio(filme a, filme b){\nreturn a.inicio &lt; b.inicio;\n}\nvoid output(vector&lt;filme&gt; assistir){\nfor (int i = 0; i &lt; 24; i++){\ncout &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; i; cout &lt;&lt; \" - \";\n}\ncout &lt;&lt; endl;\nfor (size_t i = 0; i &lt; assistir.size(); i++){\nfor (int j = 0; j &lt; assistir[i].inicio; j++){\ncout &lt;&lt; \"     \";\n}\n//cout &lt;&lt; assistir[i].inicio;\nif(assistir[i].categoria == 1){\ncout &lt;&lt; \"\\033[1;31m\";//vermelho\n}\nelse if(assistir[i].categoria == 2){\ncout &lt;&lt; \"\\033[1;32m\";//verde\n}\nelse if(assistir[i].categoria == 3){\ncout &lt;&lt; \"\\033[1;33m\";//azul\n}\nelse if(assistir[i].categoria == 4){\ncout &lt;&lt; \"\\033[1;34m\";//amarelo\n}\nelse if(assistir[i].categoria == 5){\ncout &lt;&lt; \"\\033[1;35m\";\n}\nelse{\ncout &lt;&lt; \"\\033[1;36m\";\n}\nfor(int j = 0; j &lt; assistir[i].duracao; j++){\ncout &lt;&lt; \"\\u25A0\";\ncout &lt;&lt; \"\\u25A0\";\ncout &lt;&lt; \"\\u25A0\";\n}\nfor(int j = 0; j &lt; assistir[i].duracao + 1; j++){\ncout &lt;&lt; \"\\u25A0\";\ncout &lt;&lt; \"\\u25A0\";\n}\ncout &lt;&lt; endl;\n}\n}\n</code></pre>"},{"location":"heuristicas/Aleatoria/#desempenho","title":"Desempenho","text":"<pre><code>--------------------------------------------------------------------------------\n-- User-annotated source: projetoAleatorio.cpp\n--------------------------------------------------------------------------------\nIr      \n\n-- line 19 ----------------------------------------\n      .  };\n      .  \n      .  \n      .  bool ord_duracao(filme a, filme b);\n      .  bool ord_inicio(filme a, filme b);\n      .  void output(vector&lt;filme&gt; assistir);\n      .  \n      .  \n     14  int main(int argc, char *argv[]){\n      .  \n      5      ifstream inFile;\n  6,210  =&gt; ???:0x000000000010a390 (1x)\n    778  =&gt; ???:0x000000000010a270 (1x)\n      1      string fileName = argv[1]; \n      .      int n;\n      .      int nCat;\n      .      int cat;\n      .  \n      .      vector&lt;int&gt; categorias;\n      .      vector&lt;bool&gt; agenda;\n      .      vector&lt;filme&gt; filmes;\n      .      vector&lt;filme&gt; assistir;\n      .      vector&lt;filme&gt; melhor;\n      .      vector&lt;filme&gt; tmp;\n      .      assistir.reserve(24);\n      .  \n      .      default_random_engine generator (10);\n      .      uniform_real_distribution&lt;double&gt; distribution(0.0, 1.0);\n      .  \n     11      inFile.open(\"inputs/\" + fileName + \".txt\");\n  6,651  =&gt; ???:0x000000000010a330 (1x)\n    101  =&gt; /usr/include/c++/9/bits/basic_string.h:std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; std::operator+&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;&amp;&amp;, char const*) (1x)\n      2      if (!inFile) {\n      .          cout &lt;&lt; \"Unable to open file\";\n      .          exit(1); // terminate with error\n      .      }\n      .  \n      3      inFile &gt;&gt; n;\n  6,007  =&gt; ???:0x000000000010a2e0 (1x)\n      3      inFile &gt;&gt; nCat;\n    405  =&gt; ???:0x000000000010a2e0 (1x)\n      .  \n     22      for (int i = 0; i &lt; nCat; i++){\n     15          inFile &gt;&gt; cat;\n  2,187  =&gt; ???:0x000000000010a2e0 (5x)\n      .          categorias.push_back(cat);\n      .      }\n      .  \n     48      for (int i = 0; i &lt; 24; i++){\n      .          agenda.push_back(true);\n      .      }\n      .  \n 56,030      for(int i = 0; i &lt; n; i++){\n      .          filme k;\n      .          int inicio, fim, categoria;\n 30,000          inFile &gt;&gt; inicio;\n4,362,922  =&gt; ???:0x000000000010a2e0 (10,000x)\n 30,001          inFile &gt;&gt; fim;\n4,361,274  =&gt; ???:0x000000000010a2e0 (10,000x)\n 30,000          inFile &gt;&gt; categoria;\n4,050,376  =&gt; ???:0x000000000010a2e0 (10,000x)\n 40,000          if(fim &gt; inicio){\n  8,690              k.fim = fim;\n  8,690              k.inicio = inicio;\n 17,380              k.duracao = k.fim - k.inicio;\n 17,380              k.categoria = categoria;\n 17,380              k.id = i + 3;\n      .              filmes.push_back(k);\n      .          }        \n      .      }\n      .  \n      .      bool disponivel = true;\n      .      int maratona = 0;\n      2      size_t maxFilmes = 0;\n      .      sort(filmes.begin(), filmes.end(), ord_duracao);\n      .      \n      2      chrono::steady_clock::time_point start = chrono::steady_clock::now();\n    937  =&gt; ???:0x000000000010a3e0 (1x)\n      .      sort(filmes.begin(), filmes.end(), ord_inicio);\n      7      tmp = filmes;\n174,165  =&gt; /usr/include/c++/9/bits/vector.tcc:std::vector&lt;filme, std::allocator&lt;filme&gt; &gt;::operator=(std::vector&lt;filme, std::allocator&lt;filme&gt; &gt; const&amp;) (1x)\n      .  \n     30      for (int t = 0; t &lt; 10; t++){    \n     30          filmes = tmp;\n1,738,978  =&gt; /usr/include/c++/9/bits/vector.tcc:std::vector&lt;filme, std::allocator&lt;filme&gt; &gt;::operator=(std::vector&lt;filme, std::allocator&lt;filme&gt; &gt; const&amp;) (10x)\n      .          assistir.clear();\n225,917          for (size_t i = 0; i &lt; filmes.size(); i++){\n277,928              disponivel = all_of(agenda.begin() + filmes[i].inicio, agenda.begin() + filmes[i].fim, [](bool b){ return b == true; });\n194,582              if (categorias[filmes[i].categoria - 1] &lt;= 0){\n      .                  disponivel = false;\n      .              }\n      .              if (disponivel){\n      .                  int categoria_index = filmes[i].categoria - 1;\n    114                  for (int k = filmes[i].inicio; k &lt; filmes[i].fim; k++){\n     10                      agenda[k] = false;\n      .                  }\n      .                  assistir.push_back(filmes[i]);\n      .                  maratona += filmes[i].duracao;\n     20                  categorias[categoria_index] -= 1; \n      .              }  \n      .              disponivel = true; \n      .  \n208,446              if(distribution(generator) &lt; 0.25){\n 52,263                  uniform_int_distribution&lt;int&gt; distribution(i, filmes.size()-1);\n      .                  int p = distribution(generator);\n 69,684                  disponivel = all_of(agenda.begin() + filmes[p].inicio, agenda.begin() + filmes[p].fim, [](bool b){ return b == true; });\n 50,031                  if (categorias[filmes[p].categoria - 1] &lt;= 0){\n      .                      disponivel = false;\n      .                  }\n      .                  if (disponivel){\n      .                      int categoria_index = filmes[p].categoria - 1;\n    670                      for (int k = filmes[p].inicio; k &lt; filmes[p].fim; k++){\n     65                          agenda[k] = false;\n      .                      }\n      .                      assistir.push_back(filmes[p]);\n      .                      maratona += filmes[p].duracao;\n    130                      categorias[categoria_index] -= 1; \n      .                  }  \n      .                  filmes.erase(filmes.begin() + p);\n 52,263                  disponivel = true; \n      .              }\n      .  \n      .          }\n     20          if(maxFilmes &lt; assistir.size()){\n      .              maxFilmes = assistir.size();\n     12              melhor = assistir;\n  1,312  =&gt; /usr/include/c++/9/bits/vector.tcc:std::vector&lt;filme, std::allocator&lt;filme&gt; &gt;::operator=(std::vector&lt;filme, std::allocator&lt;filme&gt; &gt; const&amp;) (3x)\n      .          }\n    730          for (int i = 0; i &lt; 24; i++){\n     10              agenda[i] = true;\n      .          }\n      .      }\n      2      chrono::steady_clock::time_point end = chrono::steady_clock::now();\n     40  =&gt; ???:0x000000000010a3e0 (1x)\n      .  \n      7      cout &lt;&lt; n &lt;&lt; ' ' &lt;&lt; nCat &lt;&lt; ' ' &lt;&lt; chrono::duration_cast&lt;chrono::microseconds&gt;(end-start).count() &lt;&lt; ' ' &lt;&lt; melhor.size() &lt;&lt; endl;\n  7,812  =&gt; ???:0x000000000010a450 (2x)\n      .  \n     19      if(argc &gt; 2 &amp;&amp; strcmp(argv[2], \"-output\") == 0){ \n      .          cout &lt;&lt; \"Quantidade de filmes:\" &lt;&lt; melhor.size() &lt;&lt; endl;\n      .          //cout &lt;&lt; \"Tempo para assistir:\" &lt;&lt; maratona &lt;&lt; endl;\n      .  \n      .          sort(melhor.begin(), melhor.end(), ord_inicio);\n      .  \n      2          output(melhor);\n 99,700  =&gt; projetoAleatorio.cpp:output(std::vector&lt;filme, std::allocator&lt;filme&gt; &gt;) (1x)\n      .      }\n      .  \n      4      ofstream outFile;\n  8,665  =&gt; ???:0x000000000010a3f0 (1x)\n  2,424  =&gt; ???:0x000000000010a440 (1x)\n     13      outFile.open(\"outputs/aleatorio/out_\" + to_string(n) + \"_\" + to_string(nCat) + \".txt\");\n  1,163  =&gt; /usr/include/c++/9/bits/basic_string.h:std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; std::operator+&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;&amp;&amp;, char const*) (2x)\n    935  =&gt; ???:0x000000000010a2b0 (1x)\n      2      if (!outFile) {\n      .          cout &lt;&lt; \"Unable to open file\";\n      .          exit(1); // terminate with error\n      .      }\n      .  \n      8      outFile &lt;&lt;  n &lt;&lt; ' ' &lt;&lt; nCat &lt;&lt; ' ' &lt;&lt; chrono::duration_cast&lt;chrono::microseconds&gt;(end-start).count() &lt;&lt; ' ' &lt;&lt; assistir.size() &lt;&lt; endl;\n  1,817  =&gt; ???:0x000000000010a450 (2x)\n      .  \n      .      return 0;\n     12  }\n      .  \n 96,849  bool ord_duracao(filme a, filme b){\n290,547      return a.duracao &lt; b.duracao;\n 96,849  }\n      .  \n101,079  bool ord_inicio(filme a, filme b){\n303,237      return a.inicio &lt; b.inicio;\n101,079  }\n      .  \n     12  void output(vector&lt;filme&gt; assistir){\n     73      for (int i = 0; i &lt; 24; i++){\n     72          cout &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; i; \n 13,410  =&gt; ???:0x000000000010a450 (24x)\n      .          cout &lt;&lt; \" - \";\n      .      }\n      .  \n      .      cout &lt;&lt; endl;\n      .      \n     70      for (size_t i = 0; i &lt; assistir.size(); i++){\n    459          for (int j = 0; j &lt; assistir[i].inicio; j++){\n      .             cout &lt;&lt; \"     \";\n      .          }\n      .          \n      .          //cout &lt;&lt; assistir[i].inicio;\n     39          if(assistir[i].categoria == 1){\n      .              cout &lt;&lt; \"\\033[1;31m\";//vermelho\n      .          }\n     24          else if(assistir[i].categoria == 2){\n      .              cout &lt;&lt; \"\\033[1;32m\";//verde\n      .          }\n     16          else if(assistir[i].categoria == 3){\n      .              cout &lt;&lt; \"\\033[1;33m\";//azul\n      .          }\n      6          else if(assistir[i].categoria == 4){\n      .              cout &lt;&lt; \"\\033[1;34m\";//amarelo\n      .          }\n      .          else if(assistir[i].categoria == 5){\n      .              cout &lt;&lt; \"\\033[1;35m\";\n      .          }\n      .          else{\n      .              cout &lt;&lt; \"\\033[1;36m\";\n      .          }\n    193          for(int j = 0; j &lt; assistir[i].duracao; j++){\n      .              cout &lt;&lt; \"\\u25A0\";\n      .              cout &lt;&lt; \"\\u25A0\";\n      .              cout &lt;&lt; \"\\u25A0\";\n      .          }\n    196          for(int j = 0; j &lt; assistir[i].duracao + 1; j++){\n      .              cout &lt;&lt; \"\\u25A0\";\n      .              cout &lt;&lt; \"\\u25A0\";\n      .          }\n      .          cout &lt;&lt; endl;\n      .      }\n      .  \n     11  }\n--------------------------------------------------------------------------------\nIr        \n--------------------------------------------------------------------------------\n2,379,521  events annotated\n</code></pre>"},{"location":"heuristicas/Aleatoria/#resultados","title":"Resultados","text":"<p>Representa\u00e7\u00e3o geral da performace</p> <p> </p>"},{"location":"heuristicas/Exaustiva/","title":"Exaustiva","text":""},{"location":"heuristicas/Exaustiva/#definicao","title":"Defini\u00e7\u00e3o","text":"<p>A heur\u00edstica exaustiva \u00e9 um algoritmo de busca que explora todas as possibilidades para encontrar a melhor solu\u00e7\u00e3o entre elas.</p> <p>Ao contr\u00e1rio das heur\u00edsticas gulosa e aleatoria, que fazem escolhas locais em cada etapa, a heur\u00edstica exaustiva examina todas as op\u00e7\u00f5es dispon\u00edveis, calculando o resultado de cada uma delas. Ela avalia todas as combina\u00e7\u00f5es poss\u00edveis e escolhe aquela de melhor resultado.</p>"},{"location":"heuristicas/Exaustiva/#vantagens","title":"Vantagens","text":"<ul> <li>Solu\u00e7\u00e3o \u00f3tima: como a heur\u00edstica exaustiva explora todas as possibilidades, ela garante encontrar a melhor solu\u00e7\u00e3o poss\u00edvel.</li> <li>Precis\u00e3o: ao considerar todas as op\u00e7\u00f5es, a heur\u00edstica exaustiva n\u00e3o deixa de lado nenhuma possibilidade que possa levar a uma solu\u00e7\u00e3o globalmente melhor.</li> </ul>"},{"location":"heuristicas/Exaustiva/#desvantagens","title":"Desvantagens","text":"<ul> <li>Complexidade computacional: a heur\u00edstica exaustiva avalia todas as combina\u00e7\u00f5es, o que pode levar a um alto tempo de execu\u00e7\u00e3o e consumo de recursos computacionais.</li> </ul>"},{"location":"heuristicas/Exaustiva/#aplicacao","title":"Aplica\u00e7\u00e3o","text":"<p>Por causa da sua alta demanda computacional a heur\u00edstica exaustiva foi utilizada para explorar diferentes tecnicas de paralelismo.</p>"},{"location":"heuristicas/Exaustiva/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<pre><code>#include&lt;iostream&gt;\n#include&lt;iomanip&gt;\n#include&lt;vector&gt;\n#include&lt;fstream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\n#include&lt;chrono&gt;\n#include&lt;math.h&gt;\nusing namespace std;\nstruct filme{\nint inicio;\nint fim;\nint categoria;\nint duracao;\nint id;\n};\nbool ord_duracao(filme a, filme b);\nbool ord_inicio(filme a, filme b);\nvoid output(vector&lt;filme&gt; assistir);\nint main(int argc, char *argv[]){\nifstream inFile;\nstring fileName = argv[1]; int n;\nint nCat;\nint cat;\nvector&lt;int&gt; categorias;\nvector&lt;bool&gt; agenda;\nvector&lt;filme&gt; filmes;\nvector&lt;filme&gt; assistir;\nassistir.reserve(24);\nagenda.reserve(24);\ninFile.open(\"inputs/\" + fileName + \".txt\");\nif (!inFile) {\ncout &lt;&lt; \"Unable to open file\";\nexit(1); // terminate with error\n}\ninFile &gt;&gt; n;\ninFile &gt;&gt; nCat;\nfor (int i = 0; i &lt; nCat; i++){\ninFile &gt;&gt; cat;\ncategorias.push_back(cat);\n}\nfor(int i = 0; i &lt; n; i++){\nfilme k;\nint inicio, fim, categoria;\ninFile &gt;&gt; inicio;\ninFile &gt;&gt; fim;\ninFile &gt;&gt; categoria;\nif(fim &gt; inicio){\nk.fim = fim;\nk.inicio = inicio;\nk.duracao = k.fim - k.inicio;\nk.categoria = categoria;\nk.id = i + 3;\nfilmes.push_back(k);\n}        }\nbool disponivel = true;\nint maratona = 0;\nint tested = 0;\nchrono::steady_clock::time_point start = chrono::steady_clock::now();\nconst long long unsigned int slent = pow(2, min(int (filmes.size()), 50));\nint melhor = 0;\nfor (long long unsigned int i = 0; i &lt; slent; i++) {\nfor (int i = 0; i &lt; 24; i++){\nagenda[i] = true;\n}\nint added = 0;\nfor (size_t j = 0; j &lt; filmes.size(); j++){\nif(added &gt; 24 || added &lt; 0) continue;\nif ((i &amp; int(pow(2, j)))) {\ndisponivel = all_of(agenda.begin() + filmes[j].inicio, agenda.begin() + filmes[j].fim, [](bool b){ return b == true; });\nif (categorias[filmes[j].categoria - 1] &lt;= 0){\ndisponivel = false;\n}\nif (disponivel){\nfor (int k = filmes[j].inicio; k &lt; filmes[j].fim; k++){\nagenda[k] = false;\n}\nassistir.push_back(filmes[j]);\nmaratona += filmes[j].duracao;\ncategorias[filmes[j].categoria - 1] = categorias[filmes[j].categoria - 1] - 1;  }  disponivel = true; added++;\n}\n}\nchrono::steady_clock::time_point end = chrono::steady_clock::now();\ntested++;\nif(chrono::duration_cast&lt;chrono::microseconds&gt;(end-start).count() &gt; 30000000) {\ncout &lt;&lt; 30 &lt;&lt; 'x' &lt;&lt; slent &lt;&lt; 'x' &lt;&lt; tested;\nexit(0);\n}\nif(added &lt;= 24 &amp;&amp; added &gt; 0) {\nif(added &gt; melhor) {\nmelhor = added;\n}\n}\n}\ncout &lt;&lt; 30 &lt;&lt; 'x' &lt;&lt; slent &lt;&lt; 'x' &lt;&lt; tested;\nreturn 0;\n}\n</code></pre>"},{"location":"heuristicas/Gulosa/","title":"Gulosa","text":""},{"location":"heuristicas/Gulosa/#definicao","title":"Defini\u00e7\u00e3o","text":"<p>Heur\u00edstica gulosa \u00e9 um algoritmo de busca (greedy) que segue um processo unico de sele\u00e7\u00e3o em cada passo.</p> <p>O algoritmo possui uma regra de decis\u00e3o unica e a aplica a cada passo, seleciona a op\u00e7\u00e3o valida que aparecer primeiro, sem levar em considera\u00e7\u00e3o o impacto de longo prazo dessa escolha. Dessa forma, a heur\u00edstica gulosa busca maximizar uma fun\u00e7\u00e3o objetivo ou minimizar um custo de forma incremental, esperando que a soma das escolhas locais leve a uma solu\u00e7\u00e3o aceit\u00e1vel, uma vez que pode terminar antes de observar diver\u00e7as op\u00e7\u00f5es.</p>"},{"location":"heuristicas/Gulosa/#vantagens","title":"Vantagens","text":"<ul> <li>Efici\u00eancia: as heur\u00edsticas gulosas geralmente s\u00e3o algoritmos de baixa complexidade computacional.</li> <li>Facilidade de implementa\u00e7\u00e3o: em compara\u00e7\u00e3o com outras t\u00e9cnicas de otimiza\u00e7\u00e3o, as heur\u00edsticas gulosas s\u00e3o relativamente f\u00e1ceis de implementar.</li> </ul>"},{"location":"heuristicas/Gulosa/#desvantagens","title":"Desvantagens","text":"<ul> <li>Solu\u00e7\u00f5es sub-\u00f3timas: a baixa explora\u00e7\u00e3o favorece a melhor op\u00e7\u00e3o local, ignora op\u00e7\u00f5es que parecem menos vantajosas no momento, mas que poderiam levar a uma solu\u00e7\u00e3o global melhor.</li> </ul>"},{"location":"heuristicas/Gulosa/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<pre><code>#include&lt;iostream&gt;\n#include&lt;iomanip&gt;\n#include&lt;vector&gt;\n#include&lt;fstream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\n#include&lt;chrono&gt;\nusing namespace std;\nstruct filme{\nint inicio;\nint fim;\nint categoria;\nint duracao;\nint id;\n};\nbool ord_duracao(filme a, filme b);\nbool ord_inicio(filme a, filme b);\nvoid output(vector&lt;filme&gt; assistir);\nint main(int argc, char *argv[]){\nifstream inFile;\nstring fileName = argv[1]; int n;\nint nCat;\nint cat;\nvector&lt;int&gt; categorias;\nvector&lt;bool&gt; agenda;\nvector&lt;filme&gt; filmes;\nvector&lt;filme&gt; assistir;\nassistir.reserve(24);\ninFile.open(\"inputs/\" + fileName + \".txt\");\nif (!inFile) {\ncout &lt;&lt; \"Unable to open file\";\nexit(1); // terminate with error\n}\ninFile &gt;&gt; n;\ninFile &gt;&gt; nCat;\nfor (int i = 0; i &lt; nCat; i++){\ninFile &gt;&gt; cat;\ncategorias.push_back(cat);\n}\nfor (int i = 0; i &lt; 24; i++){\nagenda.push_back(true);\n}\nfor(int i = 0; i &lt; n; i++){\nfilme k;\nint inicio, fim, categoria;\ninFile &gt;&gt; inicio;\ninFile &gt;&gt; fim;\ninFile &gt;&gt; categoria;\nif(fim &gt; inicio){\nk.fim = fim;\nk.inicio = inicio;\nk.duracao = k.fim - k.inicio;\nk.categoria = categoria;\nk.id = i + 3;\nfilmes.push_back(k);\n}        }\nbool disponivel = true;\nint maratona = 0;\nchrono::steady_clock::time_point start = chrono::steady_clock::now();\nsort(filmes.begin(), filmes.end(), ord_inicio);\nfor (size_t i = 0; i &lt; filmes.size(); i++){\ndisponivel = all_of(agenda.begin() + filmes[i].inicio, agenda.begin() + filmes[i].fim, [](bool b){ return b == true; });\nif (categorias[filmes[i].categoria - 1] &lt;= 0){\ndisponivel = false;\n}\nif (disponivel){\nfor (int k = filmes[i].inicio; k &lt; filmes[i].fim; k++){\nagenda[k] = false;\n}\nassistir.push_back(filmes[i]);\nmaratona += filmes[i].duracao;\ncategorias[filmes[i].categoria - 1] = categorias[filmes[i].categoria - 1] - 1;  }  disponivel = true; }\nchrono::steady_clock::time_point end = chrono::steady_clock::now();\n//cout &lt;&lt; chrono::duration_cast&lt;chrono::microseconds&gt;(end-start).count() &lt;&lt; endl;\ncout &lt;&lt; n &lt;&lt; ' ' &lt;&lt; nCat &lt;&lt; ' ' &lt;&lt; chrono::duration_cast&lt;chrono::microseconds&gt;(end-start).count() &lt;&lt; ' ' &lt;&lt; assistir.size() &lt;&lt; endl;\nif(argc &gt; 2 &amp;&amp; strcmp(argv[2], \"-output\") == 0){  cout &lt;&lt; \"Quantidade de filmes:\" &lt;&lt; assistir.size() &lt;&lt; endl;\ncout &lt;&lt; \"Tempo para assistir:\" &lt;&lt; maratona &lt;&lt; endl;\nsort(assistir.begin(), assistir.end(), ord_inicio);\noutput(assistir);\n}\nofstream outFile;\noutFile.open(\"outputs/guloso/out_\" + to_string(n) + \"_\" + to_string(nCat) + \".txt\");\nif (!outFile) {\ncout &lt;&lt; \"Unable to open file\";\nexit(1); // terminate with error\n}\noutFile &lt;&lt;  n &lt;&lt; ' ' &lt;&lt; nCat &lt;&lt; ' ' &lt;&lt; chrono::duration_cast&lt;chrono::microseconds&gt;(end-start).count() &lt;&lt; ' ' &lt;&lt; assistir.size() &lt;&lt; endl;\nreturn 0;\n}\nbool ord_duracao(filme a, filme b){\nreturn a.duracao &lt; b.duracao;\n}\nbool ord_inicio(filme a, filme b){\nreturn a.inicio &lt; b.inicio;\n}\nvoid output(vector&lt;filme&gt; assistir){\nfor (int i = 0; i &lt; 24; i++){\ncout &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; i; cout &lt;&lt; \" - \";\n}\ncout &lt;&lt; endl;\nfor (size_t i = 0; i &lt; assistir.size(); i++){\nfor (int j = 0; j &lt; assistir[i].inicio; j++){\ncout &lt;&lt; \"     \";\n}\n//cout &lt;&lt; assistir[i].inicio;\nif(assistir[i].categoria == 1){\ncout &lt;&lt; \"\\033[1;31m\";//vermelho\n}\nelse if(assistir[i].categoria == 2){\ncout &lt;&lt; \"\\033[1;32m\";//verde\n}\nelse if(assistir[i].categoria == 3){\ncout &lt;&lt; \"\\033[1;33m\";//azul\n}\nelse if(assistir[i].categoria == 4){\ncout &lt;&lt; \"\\033[1;34m\";//amarelo\n}\nelse if(assistir[i].categoria == 5){\ncout &lt;&lt; \"\\033[1;35m\";\n}\nelse{\ncout &lt;&lt; \"\\033[1;36m\";\n}\nfor(int j = 0; j &lt; assistir[i].duracao; j++){\ncout &lt;&lt; \"\\u25A0\";\ncout &lt;&lt; \"\\u25A0\";\ncout &lt;&lt; \"\\u25A0\";\n}\n// 1 - 1, 2 - 2, 3 -3 \nfor(int j = 0; j &lt; assistir[i].duracao + 1; j++){\ncout &lt;&lt; \"\\u25A0\";\ncout &lt;&lt; \"\\u25A0\";\n}\n//cout &lt;&lt; \"\\033[0m\";\n// \n//cout &lt;&lt; assistir[i].fim;\ncout &lt;&lt; endl;\n}\n}\n</code></pre>"},{"location":"heuristicas/Gulosa/#desempenho","title":"Desempenho","text":"<pre><code>--------------------------------------------------------------------------------\n-- User-annotated source: projetoGuloso.cpp\n--------------------------------------------------------------------------------\nIr      \n\n-- line 18 ----------------------------------------\n      .  \n      .  \n      .  \n      .  bool ord_duracao(filme a, filme b);\n      .  bool ord_inicio(filme a, filme b);\n      .  void output(vector&lt;filme&gt; assistir);\n      .  \n      .  \n     14  int main(int argc, char *argv[]){\n      .  \n      5      ifstream inFile;\n  6,210  =&gt; ???:0x000000000010a390 (1x)\n    778  =&gt; ???:0x000000000010a270 (1x)\n      1      string fileName = argv[1]; \n      .      int n;\n      .      int nCat;\n      .      int cat;\n      .  \n      .      vector&lt;int&gt; categorias;\n      .      vector&lt;bool&gt; agenda;\n      .      vector&lt;filme&gt; filmes;\n      .      vector&lt;filme&gt; assistir;\n      .      assistir.reserve(24);\n      .  \n     11      inFile.open(\"inputs/\" + fileName + \".txt\");\n  6,651  =&gt; ???:0x000000000010a330 (1x)\n    101  =&gt; /usr/include/c++/9/bits/basic_string.h:std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; std::operator+&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;&amp;&amp;, char const*) (1x)\n      4      if (!inFile) {\n      .          cout &lt;&lt; \"Unable to open file\";\n      .          exit(1); // terminate with error\n      .      }\n      .  \n      3      inFile &gt;&gt; n;\n  6,007  =&gt; ???:0x000000000010a2e0 (1x)\n      3      inFile &gt;&gt; nCat;\n    405  =&gt; ???:0x000000000010a2e0 (1x)\n      .  \n     23      for (int i = 0; i &lt; nCat; i++){\n     15          inFile &gt;&gt; cat;\n  2,187  =&gt; ???:0x000000000010a2e0 (5x)\n      .          categorias.push_back(cat);\n      .      }\n      .  \n     48      for (int i = 0; i &lt; 24; i++){\n      .          agenda.push_back(true);\n      .      }\n      .  \n 56,030      for(int i = 0; i &lt; n; i++){\n      .          filme k;\n      .          int inicio, fim, categoria;\n 30,000          inFile &gt;&gt; inicio;\n4,362,922  =&gt; ???:0x000000000010a2e0 (10,000x)\n 30,001          inFile &gt;&gt; fim;\n4,361,274  =&gt; ???:0x000000000010a2e0 (10,000x)\n 30,000          inFile &gt;&gt; categoria;\n4,050,376  =&gt; ???:0x000000000010a2e0 (10,000x)\n 40,000          if(fim &gt; inicio){\n  8,690              k.fim = fim;\n  8,690              k.inicio = inicio;\n 17,380              k.duracao = k.fim - k.inicio;\n 17,380              k.categoria = categoria;\n 17,380              k.id = i + 3;\n      .              filmes.push_back(k);\n      .          }        \n      .      }\n      .  \n      .      bool disponivel = true;\n      .      int maratona = 0;\n      .      \n      2      chrono::steady_clock::time_point start = chrono::steady_clock::now();\n    937  =&gt; ???:0x000000000010a3e0 (1x)\n      .      sort(filmes.begin(), filmes.end(), ord_inicio);\n      .  \n 26,076      for (size_t i = 0; i &lt; filmes.size(); i++){\n 52,140          disponivel = all_of(agenda.begin() + filmes[i].inicio, agenda.begin() + filmes[i].fim, [](bool b){ return b == true; });\n     70          if (categorias[filmes[i].categoria - 1] &lt;= 0){\n      .              disponivel = false;\n      .          }\n      .          if (disponivel){\n    192              for (int k = filmes[i].inicio; k &lt; filmes[i].fim; k++){\n      .                  agenda[k] = false;\n      .              }\n      .              assistir.push_back(filmes[i]);\n     20              maratona += filmes[i].duracao;\n     50              categorias[filmes[i].categoria - 1] = categorias[filmes[i].categoria - 1] - 1;  \n      .          }  \n      .          disponivel = true; \n      .      }\n      .      \n      2      chrono::steady_clock::time_point end = chrono::steady_clock::now();\n     40  =&gt; ???:0x000000000010a3e0 (1x)\n      .      //cout &lt;&lt; chrono::duration_cast&lt;chrono::microseconds&gt;(end-start).count() &lt;&lt; endl;\n      .  \n      7      cout &lt;&lt; n &lt;&lt; ' ' &lt;&lt; nCat &lt;&lt; ' ' &lt;&lt; chrono::duration_cast&lt;chrono::microseconds&gt;(end-start).count() &lt;&lt; ' ' &lt;&lt; assistir.size() &lt;&lt; endl;\n  8,039  =&gt; ???:0x000000000010a450 (2x)\n      .  \n      2      if(argc &gt; 2 &amp;&amp; strcmp(argv[2], \"-output\") == 0){  \n      .          cout &lt;&lt; \"Quantidade de filmes:\" &lt;&lt; assistir.size() &lt;&lt; endl;\n      .          cout &lt;&lt; \"Tempo para assistir:\" &lt;&lt; maratona &lt;&lt; endl;\n      .  \n      .          sort(assistir.begin(), assistir.end(), ord_inicio);\n      .  \n      .          output(assistir);\n      .      }\n      .  \n      4      ofstream outFile;\n  9,244  =&gt; ???:0x000000000010a3f0 (1x)\n  2,424  =&gt; ???:0x000000000010a440 (1x)\n     14      outFile.open(\"outputs/guloso/out_\" + to_string(n) + \"_\" + to_string(nCat) + \".txt\");\n    935  =&gt; ???:0x000000000010a2b0 (1x)\n    191  =&gt; /usr/include/c++/9/bits/basic_string.h:std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; std::operator+&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;&amp;&amp;, char const*) (2x)\n      2      if (!outFile) {\n      .          cout &lt;&lt; \"Unable to open file\";\n      .          exit(1); // terminate with error\n      .      }\n      .  \n      8      outFile &lt;&lt;  n &lt;&lt; ' ' &lt;&lt; nCat &lt;&lt; ' ' &lt;&lt; chrono::duration_cast&lt;chrono::microseconds&gt;(end-start).count() &lt;&lt; ' ' &lt;&lt; assistir.size() &lt;&lt; endl;\n  1,817  =&gt; ???:0x000000000010a450 (2x)\n      .  \n      .      return 0;\n     12  }\n      .  \n      .  bool ord_duracao(filme a, filme b){\n      .      return a.duracao &lt; b.duracao;\n      .  }\n      .  \n 98,456  bool ord_inicio(filme a, filme b){\n295,368      return a.inicio &lt; b.inicio;\n 98,456  }\n      .  \n      .  void output(vector&lt;filme&gt; assistir){\n      .      for (int i = 0; i &lt; 24; i++){\n      .          cout &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; i; \n      .          cout &lt;&lt; \" - \";\n      .      }\n      .  \n      .      cout &lt;&lt; endl;\n-- line 136 ----------------------------------------\n-- line 170 ----------------------------------------\n      .              cout &lt;&lt; \"\\u25A0\";\n      .          }\n      .          //cout &lt;&lt; \"\\033[0m\";\n      .          // \n      .          //cout &lt;&lt; assistir[i].fim;\n      .          cout &lt;&lt; endl;\n      .      }\n      .  \n      3  }\n--------------------------------------------------------------------------------\nIr      \n--------------------------------------------------------------------------------\n826,562  events annotated\n</code></pre>"},{"location":"heuristicas/Gulosa/#resultados","title":"Resultados","text":"<p>Representa\u00e7\u00e3o geral da performace</p> <p></p>"},{"location":"paralelismo/Descri%C3%A7%C3%A3o/","title":"Descri\u00e7\u00e3o","text":""},{"location":"paralelismo/Descri%C3%A7%C3%A3o/#paralelismo","title":"Paralelismo","text":"<p>Paralelismo na supercomputa\u00e7\u00e3o refere-se \u00e0 capacidade de executar tarefas computacionais de forma simult\u00e2nea, dividindo-as em v\u00e1rias partes menores que podem ser processadas em paralelo por m\u00faltiplos processadores ou n\u00facleos de processamento.</p> <p>O paralelismo \u00e9 utilizado na supercomputa\u00e7\u00e3o devido \u00e0 necessidade de processar grandes volumes de dados e realizar c\u00e1lculos complexos em um tempo razo\u00e1vel. Ele oferece benef\u00edcios significativos em termos de desempenho e efici\u00eancia, permitindo que v\u00e1rias tarefas sejam executadas ao mesmo tempo, reduzindo o tempo total de processamento.</p>"},{"location":"paralelismo/Descri%C3%A7%C3%A3o/#tipos-de-paralelismo","title":"Tipos de paralelismo","text":"<p>Existem diferentes formas de paralelismo na computa\u00e7\u00e3o:</p> <p>1 - Paralelismo de tarefa: v\u00e1rias tarefas independentes s\u00e3o executadas simultaneamente em diferentes processadores. Cada processador recebe uma tarefa e as executa de forma paralela, aproveitando ao m\u00e1ximo os recursos dispon\u00edveis.</p> <p>2 - Paralelismo de dados: os dados s\u00e3o divididos em partes menores e processados simultaneamente em diferentes processadores. Cada processador manipula uma parte dos dados e, em seguida, os resultados s\u00e3o combinados para obter o resultado final.</p>"},{"location":"paralelismo/Descri%C3%A7%C3%A3o/#tecnicas-exploradas","title":"T\u00e9cnicas exploradas","text":"<p>Neste projeto foi feito uso da alta demanda computacional da heuristica exaustiva para estudar como diferentes t\u00e9cnicas de paralelismo funcionam. </p> <ul> <li>OpenMP:  OpenMP (Open Multi-Processing) \u00e9 uma API amplamente utilizada para a programa\u00e7\u00e3o paralela. O OpenMP permite adicionar diretivas para indicar as regi\u00f5es que podem ser executadas em paralelo. Essas regi\u00f5es s\u00e3o chamadas de \"regi\u00f5es paralelas\" e s\u00e3o executadas por m\u00faltiplas threads simultaneamente, compartilhando a mesma mem\u00f3ria.</li> <li>GPU:  O paralelismo em GPU (Graphics Processing Unit) refere-se \u00e0 capacidade de executar m\u00faltiplas tarefas de forma simult\u00e2nea em uma unidade de processamento gr\u00e1fico. As GPUs s\u00e3o projetadas para lidar com grandes volumes de dados e realizar c\u00e1lculos intensivos de forma eficiente.</li> <li>MPI: MPI (Message Passing Interface) \u00e9 uma biblioteca para programa\u00e7\u00e3o paralela em sistemas distribu\u00eddos. Ela fornece um conjunto de fun\u00e7\u00f5es, rotinas e diretrizes que permitem a comunica\u00e7\u00e3o e sincroniza\u00e7\u00e3o entre processos executando em diferentes n\u00f3s de um sistema distribu\u00eddo.</li> </ul>"},{"location":"paralelismo/Descri%C3%A7%C3%A3o/#metodologia","title":"Metodologia","text":"<p>Para comparar a efici\u00eancia de cada m\u00e9todo de paralelismo, registramos o n\u00famero de combina\u00e7\u00f5es que cada t\u00e9cnica foi capaz de processar em um per\u00edodo de 30 segundos, variando a quantidade de filmes como entrada.</p>"},{"location":"paralelismo/GPU/","title":"GPU","text":""},{"location":"paralelismo/GPU/#definicao","title":"Defini\u00e7\u00e3o","text":"<p>O paralelismo em GPU (Graphics Processing Unit) refere-se \u00e0 capacidade de executar m\u00faltiplas tarefas de forma simult\u00e2nea em uma unidade de processamento gr\u00e1fico. As GPUs s\u00e3o projetadas para lidar com grandes volumes de dados e realizar c\u00e1lculos intensivos de forma eficiente.</p> <p>Para aproveitar o paralelismo em GPU, \u00e9 necess\u00e1rio usar uma linguagem de programa\u00e7\u00e3o que suporte programa\u00e7\u00e3o paralela em GPU, como CUDA (Compute Unified Device Architecture) para GPUs NVIDIA ou OpenCL (Open Computing Language) para GPUs de v\u00e1rias marcas. Essas linguagens fornecem bibliotecas e APIs para escrever c\u00f3digo que pode ser executado em GPUs.</p>"},{"location":"paralelismo/GPU/#thrust","title":"Thrust","text":"<p>A biblioteca Thrust \u00e9 uma biblioteca de programa\u00e7\u00e3o paralela em C++ desenvolvida pela NVIDIA. Ela fornece um conjunto de algoritmos e estruturas de dados de alto desempenho otimizados para execu\u00e7\u00e3o em GPUs (Graphics Processing Units).</p> <p>A Thrust foi projetada para simplificar o desenvolvimento de aplicativos paralelos em GPUs, oferecendo uma interface de programa\u00e7\u00e3o amig\u00e1vel e familiar aos programadores C++. Ela segue o paradigma de programa\u00e7\u00e3o gen\u00e9rica, permitindo que os algoritmos sejam aplicados a uma ampla variedade de tipos de dados.</p>"},{"location":"paralelismo/OpenMP/","title":"OpenMP","text":""},{"location":"paralelismo/OpenMP/#definicao","title":"Defini\u00e7\u00e3o","text":"<p>OpenMP (Open Multi-Processing) \u00e9 uma API amplamente utilizada para a programa\u00e7\u00e3o paralela. O OpenMP permite adicionar diretivas para indicar as regi\u00f5es que podem ser executadas em paralelo. Essas regi\u00f5es s\u00e3o chamadas de \"regi\u00f5es paralelas\" e s\u00e3o executadas por m\u00faltiplas threads simultaneamente, compartilhando a mesma mem\u00f3ria.</p>"},{"location":"paralelismo/OpenMP/#principais-recusos","title":"Principais recusos","text":"<p>1 - Diretivas: s\u00e3o comandos especiais inseridos no c\u00f3digo-fonte para indicar as regi\u00f5es paralelas. As diretivas OpenMP s\u00e3o precedidas por \"#pragma omp\" e fornecem instru\u00e7\u00f5es para o compilador.</p> <p>2 - Cl\u00e1usulas: fornecem informa\u00e7\u00f5es adicionais sobre como a regi\u00e3o paralela deve ser executada. Por exemplo, a cl\u00e1usula \"num_threads\" especifica o n\u00famero de threads a serem usadas na regi\u00e3o paralela.</p> <p>4 - Escopo de vari\u00e1veis: compartilhamento de vari\u00e1veis entre as threads. Vari\u00e1veis declaradas fora das regi\u00f5es paralelas s\u00e3o compartilhadas, enquanto vari\u00e1veis declaradas dentro de uma regi\u00e3o paralela s\u00e3o privadas e t\u00eam uma c\u00f3pia para cada thread.</p> <p>5 - Sincroniza\u00e7\u00e3o: mecanismos para sincronizar as threads, como as diretivas \"barrier\", que aguarda todas as threads atingirem um determinado ponto de sincroniza\u00e7\u00e3o, e \"critical\", que permite que apenas uma thread execute uma se\u00e7\u00e3o cr\u00edtica por vez.</p>"},{"location":"paralelismo/OpenMP/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<pre><code>#include&lt;iostream&gt;\n#include&lt;iomanip&gt;\n#include&lt;vector&gt;\n#include&lt;fstream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\n#include&lt;chrono&gt;\n#include&lt;math.h&gt;\n#include&lt;omp.h&gt;\nusing namespace std;\nstruct filme{\nint inicio;\nint fim;\nint categoria;\nint duracao;\nint id;\n};\nbool ord_duracao(filme a, filme b);\nbool ord_inicio(filme a, filme b);\nvoid output(vector&lt;filme&gt; assistir);\nint main(int argc, char *argv[]){\nifstream inFile;\nstring fileName = argv[1]; int n;\nint nCat;\nint cat;\nvector&lt;int&gt; categorias;\nvector&lt;bool&gt; agenda;\nvector&lt;filme&gt; filmes;\nvector&lt;filme&gt; assistir;\nassistir.reserve(24);\nagenda.reserve(24);\ninFile.open(\"inputs/\" + fileName + \".txt\");\nif (!inFile) {\ncout &lt;&lt; \"Unable to open file\";\nexit(1); // terminate with error\n}\ninFile &gt;&gt; n;\ninFile &gt;&gt; nCat;\nfor (int i = 0; i &lt; nCat; i++){\ninFile &gt;&gt; cat;\ncategorias.push_back(cat);\n}\nfor(int i = 0; i &lt; n; i++){\nfilme k;\nint inicio, fim, categoria;\ninFile &gt;&gt; inicio;\ninFile &gt;&gt; fim;\ninFile &gt;&gt; categoria;\nif(fim &gt; inicio){\nk.fim = fim;\nk.inicio = inicio;\nk.duracao = k.fim - k.inicio;\nk.categoria = categoria;\nk.id = i + 3;\nfilmes.push_back(k);\n}        }\nbool disponivel = true;\nint maratona = 0;\nchrono::steady_clock::time_point start = chrono::steady_clock::now();\nint n_threads= omp_get_max_threads();\nconst long long unsigned int slent = pow(2, min(int (filmes.size()), 50));\nvector&lt;int&gt; melhores;\nvector&lt;int&gt; tested(n_threads, 0);\nmelhores.resize(n_threads);\n#pragma omp parallel\n{\nint melhor;\n#pragma omp for\nfor (long long unsigned int i = 0; i &lt; slent; i++) {\nfor (int i = 0; i &lt; 24; i++){\nagenda[i] = true;\n}\nint added = 0;\nfor (size_t j = 0; j &lt; filmes.size(); j++){\nif(added &gt; 24 || added &lt; 0) continue;\nif ((i &amp; int(pow(2, j)))) {\ndisponivel = all_of(agenda.begin() + filmes[j].inicio, agenda.begin() + filmes[j].fim, [](bool b){ return b == true; });\nif (categorias[filmes[j].categoria - 1] &lt;= 0){\ndisponivel = false;\n}\nif (disponivel){\nfor (int k = filmes[j].inicio; k &lt; filmes[j].fim; k++){\nagenda[k] = false;\n}\n//assistir.push_back(filmes[j]);\nmaratona += filmes[j].duracao;\ncategorias[filmes[j].categoria - 1] = categorias[filmes[j].categoria - 1] - 1;  }  disponivel = true; added++;\n}\n}\nchrono::steady_clock::time_point end = chrono::steady_clock::now();\ntested[omp_get_thread_num()]++;\nif(chrono::duration_cast&lt;chrono::seconds&gt;(end-start).count() &gt; 30) {\n#pragma omp critical\n{\nint sum = 0;\nfor (size_t i = 0; i &lt; n_threads; i++) {\nsum += tested[i];\n}\ncout &lt;&lt; 30 &lt;&lt; 'x' &lt;&lt; slent &lt;&lt; 'x' &lt;&lt; sum;\nexit(0);\n}\n}\nif(added &lt;= 24 &amp;&amp; added &gt; 0) {\nif(added &gt; melhor) {\nmelhor = added;\nmelhores[omp_get_thread_num()] = melhor;\n}\n}\n}\n}\nint melhor = 0;\nfor (size_t i = 0; i &lt; n_threads; i++) {\nif(melhores[i] &gt; melhor) {\nmelhor = melhores[i];\n}\n}\nint sum = 0;\nfor (size_t i = 0; i &lt; n_threads; i++) {\nsum += tested[i];\n}\ncout &lt;&lt; 30 &lt;&lt; 'x' &lt;&lt; slent &lt;&lt; 'x' &lt;&lt; sum;\nexit(0);\nreturn 0;\n}\n</code></pre>"}]}